package com.example.android.markovchain

import android.annotation.TargetApi
import android.os.Build
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.ProgressBar
import android.widget.Toast
import androidx.fragment.app.FragmentActivity
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import java.io.BufferedReader
import java.io.InputStreamReader

/**
 * This `Activity` generates random gibberish using a Markov mChain state table that was generated
 * from the King James Bible offline.
 */
@Suppress("MemberVisibilityCanBePrivate")
@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
class BibleMarkovFragment : FragmentActivity() {
    /**
     * [ProgressBar] in our layout file that is displayed while the Markov mChain state table
     * is being loaded.
     */
    lateinit var mProgressBar: ProgressBar
    /**
     * [RecyclerView] in our layout file that displays the random gibberish verses.
     */
    lateinit var mRecyclerView: RecyclerView
    /**
     * `LayoutManager` used for our [RecyclerView]
     */
    lateinit var mLayoutManager: RecyclerView.LayoutManager
    /**
     * [MarkovAdapter] used as the adapter for our [RecyclerView]
     */
    lateinit var mAdapter: MarkovAdapter
    /**
     * [Markov] instance used to generate random text to display
     */
    var mMarkov = Markov()

    /**
     * Called when the activity is starting. First we call through to our super's implementation of
     * `onCreate`, then we set our content view to our layout file R.layout.activity_bible_markov_fragment.
     * We initialize our [ProgressBar] field [mProgressBar] by fining the view in our layout with id
     * R.id.bible_markov_fragment_progress, our [RecyclerView] field [mRecyclerView] by finding the
     * view with id R.id.bible_markov_fragment, and initialize our `LayoutManager` field [mLayoutManager]
     * with a new instance of `LinearLayoutManager`. Then we call our method [initMarkov] which
     * starts a background thread to read in our offline generated Markov state table using the `load`
     * method of our [Markov] field [mMarkov] and we initialize our [MarkovAdapter] field [mAdapter]
     * with an instance of [MarkovAdapter] constructed to use our [Markov] field [mMarkov] as its
     * data generator and our [RecyclerView.LayoutManager] field [mLayoutManager] as its `LayoutManager`.
     * Next we set the adapter used by [mRecyclerView] to [mAdapter] and its `LayoutManager` to
     * [mLayoutManager]. We set the `OnClickListener` of [mProgressBar] to a lambda which will switch
     * the switch the visibility of [mProgressBar] to INVISIBLE, switch the visibility of [mRecyclerView]
     * to VISIBLE and tell our [MarkovAdapter] field [mAdapter] that its data set has changed so that
     * it will refresh the contents of [mRecyclerView] (this is done so that the [DoneListener] for
     * [mMarkov] can just call the `callOnClick` method of [mProgressBar] when it is done loading the
     * Markov state table in order to switch from the `ProgressBar` to the `RecyclerView`). Finally
     * we set the [DoneListener] of [mMarkov] to an anonymous class which will call the `callOnClick`
     * method of [mProgressBar] when `onDoneDo(mProgressBar)` is called.
     *
     * @param savedInstanceState we do not override `onSaveInstanceState` so do not use.
     */
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_bible_markov_fragment)

        mProgressBar = findViewById(R.id.bible_markov_fragment_progress)
        mRecyclerView = findViewById(R.id.bible_markov_fragment)
        mLayoutManager = LinearLayoutManager(applicationContext)

        initMarkov()
        mAdapter = MarkovAdapter(supportFragmentManager, mMarkov)
        // Set CustomAdapter as the adapter for RecyclerView.
        mRecyclerView.adapter = mAdapter
        mRecyclerView.layoutManager = mLayoutManager

        /*
         * Called when the `ProgressBar` is clicked or `View.callOnClick` is called on it. We set
         *  the visibility of our `ProgressBar` field `mProgressBar` to INVISIBLE, set the visibility
         * of our `RecyclerView` field `mRecyclerView` to VISIBLE, and notify our `MarkovAdapter`
         * field `mAdapter` that the data set has changed so that it will fill `mRecyclerView` with
         * random verses generated by our `Markov` field `mMarkov`.
         *
         * Parameter `View` of the `ProgressBar` which was clicked
         */
        mProgressBar.setOnClickListener {
            mProgressBar.visibility = View.INVISIBLE
            mRecyclerView.visibility = View.VISIBLE
            mAdapter.notifyDataSetChanged()
        }
        mMarkov.setDoneListener(object : DoneListener() {
            /**
             * Called by `DoneListener.onDone` by `Markov` when it is done reading in the
             * Markov state table. We simply call `callOnClick` using the view passed us. (The
             * Toast is just there for debugging purposes)
             *
             * @param view a View for Context for a Toast or other possible uses.
             */
            override fun onDoneDo(view: View) {
                Toast.makeText(view.context, "I am done OVERRIDE.", Toast.LENGTH_LONG).show()
                view.callOnClick()
            }
        }, mProgressBar)
    }

    /**
     * This method reads in the Markov state table contained in raw/king_james_state_table.txt
     * using a background thread. We initialize our `InputStream` variable `val inputStream` by using
     * the context of the single, global Application object of the current process to fetch a `Resources`
     * instance for the application's package and use it to open a data stream for reading the raw
     * resource with id R.raw.king_james_state_table. Then we initialize our [BufferedReader] variable
     * `val reader` with a new instance that uses an `InputStreamReader` that uses the default charset
     * when reading from `inputStream`. Next we initialize our [Thread] variable `val mThread` with
     * an anonymous class whose `run` override just calls the `load` method of our [Markov] field
     * [mMarkov] to have it read from `reader` and construct its state table from its contents.
     * Finally we call the `start` method of `mThread` to start the [Thread] running.
     */
    private fun initMarkov() {

        // InputStream for reading the raw bytes from the file R.raw.king_james_state_table from
        // which an InputStreamReader is constructed to convert the bytes to characters, and finally
        // the BufferedReader which Markov.load needs to read the file line by line.
        val inputStream = applicationContext.resources.openRawResource(R.raw.king_james_state_table)
        val reader = BufferedReader(InputStreamReader(inputStream))

        /*
         * This is the thread that will do our work. Pretty much self explanatory since Markov.load
         * does all the work. We just wrap the call in a "try" in order to catch IOException
         */
        val mThread = object : Thread() {
            override fun run() {
                mMarkov.load(reader)
            }
        }
        mThread.start()
        Log.i(TAG, "We are waiting for Markov mChain to load")
    }

    /**
     * Our static constant.
     */
    companion object {
        /**
         * TAG for logging
         */
        const val TAG = "BibleMarkovFragment"
    }
}
